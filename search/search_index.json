{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"Open Source Projects by SAP Technology Partners, for SAP Customers and SAP Service Partner <p> View all Projects under the SAP LinuxLab Open-Source Initiative on GitHub.com</p> <p></p>"},{"location":"automation_demos/","title":"Automation Demos","text":"<p>Within the SAP LinuxLab Open-Source Initiative, there are various Automation Projects; these range from upper-level Ansible Playbooks and Terraform Templates down to the lower-level Ansible Roles within Ansible Collections and Terraform Modules etc.</p> <p>The below demos focus on the upper-level, Ansible Playbooks or Terraform Templates that coordinate many activities in an end-to-end deployment.</p>"},{"location":"automation_demos/#ansible-playbooks-for-sap","title":"Ansible Playbooks for SAP","text":"<p>The following are end-to-end deployments using a single pre-defined Ansible Playbook for each SAP Software Solution Scenario, that can be quickly edited and customized for the target Infrastructure Platform and Operating System. There are 40+ SAP Software Solution Scenarios, with different SAP Software Release Versions, for 9 Infrastructure Platforms, with many versions of SLES and RHEL - see README and Detailed Documentation of Ansible Playbooks for SAP for more information.</p> <p>This includes complex scenarios with multiple hosts, High Availability, and other Ansible Playbooks for Day 2 scenarios (e.g. run SAP RFC, System Copy Export / Import) - with optional use of either:</p> <ul> <li>Ansible to provision hosts</li> <li>Ansible-to-Terraform to create a minimal landing zone and provision hosts</li> </ul>"},{"location":"automation_demos/#sap-s4hana-distributed-ha-installation","title":"SAP S/4HANA Distributed HA installation","text":"<p>Show Demo on AWS Show Demo on MS Azure Show Demo on GCP Show Demo on IBM Cloud Show Demo on IBM PowerVM Show Demo on OVirt VM Show Demo on VMware VM</p> <ul> <li>SAP Software Solution Scenario: SAP S/4HANA Distributed installation (with HA)</li> <li>Operating System: RHEL for SAP Solutions 8.8</li> <li>Infrastructure Platform: AWS EC2 Virtual Server</li> <li>Recording Date: 2024-05-26</li> <li>Code Version: Ansible Playbooks for SAP v1.0.3</li> </ul> <ul> <li>SAP Software Solution Scenario: SAP S/4HANA Distributed installation (with HA)</li> <li>Operating System: RHEL for SAP Solutions 9.2</li> <li>Infrastructure Platform: MS Azure Virtual Machine</li> <li>Recording Date: 2024-12-01</li> <li>Code Version: Ansible Playbooks for SAP v1.0.5</li> </ul>"},{"location":"automation_demos/#sap-ecc-installation","title":"SAP ECC installation","text":"<p>Show Demo on AWS</p> <ul> <li>SAP Software Solution Scenario: SAP Business Suite (ECC EhP8) with IBM Db2, Distributed installation (no HA)</li> <li>Operating System: RHEL for SAP Solutions 8.8</li> <li>Infrastructure Platform: AWS EC2 Virtual Server</li> <li>Recording Date: 2024-05-26</li> <li>Code Version: Ansible Playbooks for SAP v1.0.3</li> </ul>"},{"location":"automation_demos/#diy-ansible-playbook-using-awx","title":"DIY Ansible Playbook using AWX","text":"<p>For end-users that want to understand how to build a tailored Ansible Playbook using AWX using the functionality of the <code>community.sap_install</code> Ansible Collection, a detailed step-by-step demonstration guide is available:</p> <p>demo.sap_install using Ansible AWX for DIY deployments</p>"},{"location":"automation_demos/#terraform-templates-for-sap","title":"Terraform Templates for SAP","text":"<p>The following are end-to-end deployments using a single pre-defined Terraform Template for each SAP Software Solution Scenario. Multiple Infrastructure Platforms and Operating Systems are provided, but this project is more restrictive (limited to Sandboxes) than the Ansible Playbooks for SAP.</p> <p>For More information, see README of Terraform Templates for SAP.</p>"},{"location":"automation_demos/#sap-hana-installation","title":"SAP HANA installation","text":"<p>Show Demo on MS Azure</p> <ul> <li>SAP Software Solution Scenario: SAP HANA 2.0 SPS06, single-node</li> <li>Operating System: RHEL for SAP Solutions 8.4</li> <li>Infrastructure Platform: Azure VM (ARM only, not Classic/ASM)</li> <li>Recording Date: 2022-03-22</li> <li>Code Version: Terraform Templates for SAP v0.6.0</li> </ul>"},{"location":"automation_demos/#sap-s4hana-installation-using-sap-maintenance-planner","title":"SAP S/4HANA installation using SAP Maintenance Planner","text":"<p>Show Demo on AWS</p> <ul> <li>SAP Software Solution Scenario: SAP S/4HANA Distributed installation (with HA)</li> <li>Operating System: RHEL for SAP Solutions 8.8</li> <li>Infrastructure Platform: AWS EC2 instance (VPC environment only, not Classic)</li> <li>Recording Date: 2022-06-14</li> <li>Code Version: Terraform Templates for SAP v0.6.0</li> </ul>"},{"location":"automation_demos/#sap-s4hana-system-copy-homogeneous-with-sap-hana-backup-recovery","title":"SAP S/4HANA System Copy (Homogeneous with SAP HANA Backup / Recovery)","text":"<p>Show Demo on IBM Cloud</p> <ul> <li>SAP Software Solution Scenario: SAP S/4HANA 2021, One Host System Copy (Homogeneous) using SAP HANA complete data backup file</li> <li>Operating System: RHEL for SAP Solutions 8.4</li> <li>Infrastructure Platform: IBM Cloud Virtual Server (VPC environment only, not Classic)</li> <li>Recording Date: 2022-06-14</li> <li>Code Version: Terraform Templates for SAP v0.6.0</li> </ul>"},{"location":"automation_projects/","title":"Automation Projects and Capabilities","text":"<p>The SAP LinuxLab Open-Source Initiative include many Automation Projects, with various functionality for provisioning, installing and operating SAP Systems.</p> <p>Overall, the initiative's automation projects seek to assist SAP-run enterprises to achieve various business-focused outcomes, such as:</p> <ul> <li>SAP S/4HANA Greenfield/Re-Implementation, e.g. install from SAP Maintenance Planner</li> <li>SAP S/4HANA Brownfield/Conversion, e.g. System Copy and DMO for SUM</li> <li>SAP S/4HANA Selective Data Transition, e.g. System Copy and Shell Conversion or Mix&amp;Match</li> <li>Datacenter Exit / Cloud Service Provider switch Compute Re-locate, e.g. System Copy to new Infrastructure</li> <li>Enterprise re-structures with Spin-offs and Divestitures, e.g. System Copy and carve-out</li> <li>Enterprise re-structures with Mergers and Acquisitions, e.g. System Copy and merge</li> <li>Daily SAP Operations / Maintenance, e.g. Start/Stop SAP Systems, RFC / BAPI / Task List runs, Backup scheduled runs, SAP Kernel patching</li> </ul> Automated tasks and functionality include: <ul> <li>Provision SAP Virtual Machines (Day 0) to Infrastructure Platforms <ul> <li>AWS EC2 Virtual Server instances</li> <li>Google Cloud Compute Engine Virtual Machines</li> <li>IBM Cloud, Intel Virtual Servers and Power Virtual Servers</li> <li>Microsoft Azure Virtual Machines</li> <li>IBM PowerVM Virtual Machines (LPARs)</li> <li>OVirt (e.g. Red Hat Enterprise Linux KVM)</li> <li>KubeVirt (e.g. Red Hat OpenShift Virtualization, SUSE Rancher with Harvester HCI)</li> <li>VMware vSphere Virtual Machines</li> </ul> </li> <li>Download SAP Installation Media (Day 0) <ul> <li>SAP User ID SSO login</li> <li>Search and download by filename</li> <li>Maintenance Planner stack download</li> </ul> </li> <li>Operating System preparation for SAP (Day 0) <ul> <li>Preconfigure and tune Red Hat Enterprise Linux for SAP Solutions</li> <li>Preconfigure and tune SUSE Linux Enterprise Server for SAP Applications</li> </ul> <li>SAP Installations (Day 1) <ul> <li>Install SAP HANA via HDBLCM, any combination</li> <li>Install SAP Software via SWPM, any combination</li> <li>Install SAP High Availability with Linux Pacemaker</li> <li>Pre-completed Ansible Playbooks include:   <ul> <li>SAP HANA - Scale-Up, Scale-Up High Availability (Performance Optimized), Scale-Out</li> <li>SAP S/4HANA Foundation</li> <li>SAP S/4HANA - including Distributed High Availability with Maintenance Planner Stack</li> <li>SAP BW/4HANA - including Scale-Out</li> <li>SAP ECC - including SAP HANA, IBM Db2, Oracle DB, SAP ASE, SAP MaxDB</li> <li>SAP ECC IDES</li> <li>SAP NetWeaver AS (ABAP/JAVA)</li> <li>SAP SolMan (ABAP/JAVA)</li> <li>SAP WebDispatcher</li> </ul> </li> </ul> </li> <li>SAP Operations (Day 2) <ul> <li>Post-Install of SAP Software OS configuration</li> <li>SAP System Copy Export / Import Restore</li> <li>SAP Systems Start/Stop</li> <li>SAP Profile updates</li> <li>SAP HANA Backint backup scheduling and execution</li> <li>SAP RFC / BAPI / Task List runs</li> <li>SAP Kernel patching [WIP]</li> <li>SAP SolMan Diagnostics Agent (SDA) installation</li> </ul> </li> Automation Projects within the SAP LinuxLab Open-Source Initiative include: Project Repository Project Description ansible.playbooks_for_sap Top-level Pre-built Ansible Playbooks using the Ansible Collections for SAP; uses Ansible to provision, with optional Ansible &gt; Terraform terraform.templates_for_sap Top-level Pre-built Terraform Templates for deployment of various SAP solution scenarios, for every Cloud and Hypervisor community.sap_install Ansible Collection of Ansible Roles for various SAP software installation community.sap_operations Ansible Collection of Ansible Roles for various operational tasks with SAP Systems community.sap_infrastructure Collection of Ansible Roles for infrastructure-related tasks for SAP community.sap_launchpad Ansible Collection of Ansible Roles and Ansible Modules for various tasks using SAP Launchpad APIs community.sap_libs Collection of Ansible Modules for SAP for low-level activities which are highly reusable terraform.modules_for_sap Terraform Modules for each Cloud and Hypervisor and dynamic Ansible Playbooks for SAP installations. Subcomponent of the Terraform Templates for SAP demo.sap_install Demonstration usage of Build-your-Own community.sap_install Ansible Collection, using Ansible AWX"},{"location":"faq/","title":"FAQ","text":"<p>1. I'm an SAP Customer, can I use and amend this code for custom business purposes?</p> <p>Yes. Whether you're looking for automating deployments to kickstart a project, automate regular maintenance tasks, or run tests/sizing as part of business evaluations - under the Apache license you can extend and use for internal purposes without any concerns.</p> <p>2. I'm an SAP Services Partner, can I use and amend this code to create new products/offerings for customers?</p> <p>Yes. Any code provided in the SAP LinuxLab initiative can be re-used to create accelerators for Implementation projects and long-term Maintenance engagements. Under the Apache license you can extend and use for commercial purposes without any concerns, alothugh we do hope our SAP Service Partners will provide feedback and contributions back into the projects.</p>"},{"location":"initiative_about/","title":"Initiative Overview","text":"<p>The SAP LinuxLab Open-Source Initiative Projects are developed collaboratively between SAP Technology Partners, providing unified and modular code/tools for the benefit of SAP Customers and SAP Service Partners.</p> <p>All Projects are provided under the Apache 2.0 license, for re-use by any corporation; whether in-house, or in services / products by SAP Partners.</p> <p>The collaboration within the SAP LinuxLab Open-Source Initiative provides SAP-run Enterprises with greater consistency across different platforms, with vendor-neutrality across the technology layers.</p> <p>The projects within this initiative help SAP-run Enterprises with various tools, notably including automation of SAP Landscapes (Networking, Storage, Compute, Operating System, SAP Software), SAP tooling (e.g. sizing) and architectural guidance for SAP Landscapes.</p> <p>The ambition is to enable SAP-run Enterprises worldwide with similar daily problems, to overcome their challenges without following a singular and static approach from a single SAP Technology Partner. Instead these projects under the SAP LinuxLab can be extended and used for bespoke requirements, or used by SAP Service Partners to improve implementation and maintenance services for SAP-run Enterprises.</p> <p>Development Roadmap for each Project is available upon request, and core developer/s of each Project use <code>GitHub Issues</code> to understand Bugs and Feature Requests.</p>"},{"location":"initiative_contributions/","title":"Initiative Contributions","text":"<p>Contributions from the community are important to the long-term benefit of the SAP LinuxLab Open-Source Initiative.</p> <p>Such contributions can be code development, code review and testing / feedback (bugs, better-ifs, feature requests). This can include submission of an entire Project / Code Repository into the ownership of SAP LinuxLab Open-Source Initiative.</p>"},{"location":"initiative_contributions/#contributors-to-the-community","title":"Contributors to the community","text":"<p>All members of the Open Source Community are welcome to contribute to the SAP LinuxLab Open-Source Initiative, by using each individual Project's GitHub Repository to create GitHub Issues or GitHub Pull Requests.</p> <p>Regular contributors to a Project are awarded maintainer status, and play a more active role in the long-term development of the Project. To be awarded maintainer status, self-nomination via an existing maintainer is permitted - although existing maintainers proactively embrace contributors and this is likely to happen automatically. All maintainer requests are approved by the SAP LinuxLab Open-Source Initiative's Governance Board.</p> <p>New Project / Code Repository submissions are firstly reviewed by an existing Project Maintainer, and then submitted to the SAP LinuxLab Open-Source Initiative's Governance Board for approval; the approval is largely based upon the validation the new project does not duplicate the intent of another.</p> <p>To request new project contributions and maintainer status, please use the GitHub Discussion of the SAP LinuxLab Open-Source Initiative's website. For all other contributions, please use the GitHub Issues on the respective Project's GitHub Repository.</p>"},{"location":"initiative_contributions/#contribution-workflow-with-github","title":"Contribution workflow with GitHub","text":"<p>The SAP LinuxLab Open-Source Initiative uses fork-based git flow.</p> <p>The majority of existing Projects use a simplified code contribution process to feel familiar to SAP practitioners:</p> <ul> <li>Each GitHub Repository will have a <code>main</code> branch (effectively \"Production\") and use Git Tags to define individual Git Releases.</li> <li>Each GitHub Repository will have a <code>dev</code> branch where code development contributions are merged into and tested (effectively \"Integration Test\").</li> <li>Each developer will fork the repository into a personal GitHub Repository, and create their own branch e.g. <code>new-feat001</code> (effectively \"Sandbox\"); which are merged into the aforementioned <code>dev</code> branch using a GitHub Pull Request.</li> </ul> <p>At a high-level, the steps in sequence to add code contributions is therefore:</p> <ul> <li>Fork the GitHub Repository for which you want to make a contribution</li> <li>Create a separate branch for the work</li> <li>Create a GitHub Pull Request back to the original GitHub Repository</li> <li>Adjust the work based on comments received</li> <li>Await the merge of the GitHub Pull Request by another committer</li> </ul>"},{"location":"initiative_contributions/#general-guidance-for-contributions","title":"General guidance for contributions","text":"<p>When making a contribution to a Project within the SAP LinuxLab Open-Source Initiative, please try to utilize the following set of developer guidelines.</p> <p>Please note, these developer guidelines may require more practice with using Git tooling (such as squashing commits):</p> <p>Do:</p> <ul> <li>Keep it simple</li> <li>Follow coding style guides where they exist</li> <li>Write tests or show test evidence when applicable</li> <li>Review existing content in order to avoid overwriting existing content</li> <li>Create documentation, especially for new features and functionality</li> <li>Discuss with other committers whenever you are unsure of something</li> <li>Engage with the community and with contributors</li> <li>Squash commits whenever possible</li> <li>Use <code>pre-commit</code> to avoid pushing non-standardized code</li> <li>Avoid incorrect commits, by using Linter tools to check code syntax or CodeSpell for spelling mistakes; for example Ansible Development guidelines.</li> </ul> <p>Don\u2019t:</p> <ul> <li>Commit directly or open pull request to the <code>main</code> branch</li> <li>Merge pull requests you have authored yourself, wait for a code review by another member</li> <li>Break existing functionality</li> <li>Ignore requests for assistance</li> </ul>"},{"location":"initiative_contributions/#governance-board","title":"Governance Board","text":"<p>The SAP LinuxLab Open-Source Initiative is managed by a Governance Board that consists of at least one person of each foundation company. This board helps to keep vendor neutrality, approve new contributions and define roadmap, structure and other rules (e.g. naming conventions).</p> <p>The Governance Board meets on a monthly cadence.</p> <p>See the current list of participating companies, the list does not include those companies who actively use and provide feedback but do not actively provide code contributions.</p>"},{"location":"initiative_contributions/#maintainers","title":"Maintainers","text":"<p>For each Project's GitHub Repository under the SAP LinuxLab Open-Source Initiative, one or two responsible maintainers are elected. The maintainers take responsibility for the roadmap of the repository they maintain.</p> <p>On larger Projects (e.g. <code>sap_install</code> Ansible Collection), maintainers are defined by sub-component of the Project (keeping with the example, Ansible Roles each have a maintainer within the Ansible Collection).</p> <p>Each maintainer is responsible for watching, commenting and prioritizing GitHub Issues and GitHub Pull Requests in a timely manner.</p>"},{"location":"initiative_contributions/#project-naming-conventions","title":"Project Naming Conventions","text":"<p>To aid new-users easily finding content, Project GitHub Repositories follow naming convention prefixes. Often the prefix is the technology used, unless an existing nomenclature exists for the given technology (e.g. Ansible uses prefix <code>community.</code> for community upstream Ansible Collections).</p> Category Content type Prefix Automation (Infrastructure-as-Code) Terraform Templates (and Modules) <code>terraform.</code>description Kubernetes (Source-to-Image) <code>k8s.</code>description Automation (Configuration-as-Code) Ansible Collections (and Roles or Modules) <code>community.</code>collection_name Salt <code>salt.</code>description Shell scripts Tools and Utilities <code>tool.</code>description Documentation Architectures <code>architecture.</code>sap_product_name <sub>(1..n Solution Architectures)</sub> Special Topics High Availability <code>high-availability.</code>description Misc. Demos and Examples <code>demo.</code>description"},{"location":"initiative_participating_companies/","title":"Initiative Participants","text":"Founding Members Project Contributors"},{"location":"other_projects/","title":"Other Projects","text":"<p>Other Projects within the SAP LinuxLab Open-Source Initiative include:</p> Project Repository Project Description tool.sap_infrastructure_actions Scripts to perform Infrastructure actions for SAP operations tool.sapcontrol-bash-completion bash completion for the sapcontrol command tool.sap_sizing_calculators Calculations to assist SAP Technical Administrators in sizing decisions for designing and deploying SAP Landscapes high-availability.overview Overview on High Availability  for SAP deployments architecture.sap_hana OUTDATED: Reference Architecture for SAP HANA for every Cloud and Hypervisor"},{"location":"initiative_contribute/__ansible_dev_guidelines/","title":"Development Guidelines","text":""},{"location":"initiative_contribute/__ansible_dev_guidelines/#ansible-collections-and-roles-for-sap","title":"Ansible Collections and Roles for SAP","text":""},{"location":"initiative_contribute/__ansible_dev_guidelines/#blocks-and-tasks","title":"Blocks and Tasks","text":"<p>All blocks and tasks must be named and must have a unique name in each role.</p>"},{"location":"initiative_contribute/__ansible_dev_guidelines/#variable-naming","title":"Variable Naming","text":"<p>Role variables must be named as follows (example role name: sample_role)</p> <ul> <li>Role external variables start with the role name, as in:</li> </ul> <pre><code>sample_role_required_packages: ''\n</code></pre> <ul> <li>Role internal variables start with two underscores, followed by the role name, as in:</li> </ul> <pre><code>__sample_role_required_packages: ''\n</code></pre> <ul> <li>Role variables which store the result of a set_fact has the string \"_fact\" after the role name part, as in:</li> </ul> <pre><code>__sample_role_fact_required_packages: ''\n</code></pre> <ul> <li>Role variables which store the result of a function other than set_fact has the string \"_register\" after the role name part, as in:</li> </ul> <pre><code>__sample_role_register_installed_packages: ''\n</code></pre>"},{"location":"initiative_contribute/__ansible_dev_guidelines/#ansible-lint-cleaning","title":"Ansible-lint Cleaning","text":"<p>Only ansible-lint clean Ansible Collections can be imported into Ansible Galaxy.</p> <p>Then the linting files <code>.ansible-lint</code> and <code>.yamllint.yml</code> are automatically maintained and installed by any <code>git clone</code> or <code>git pull</code> request.  The correct linting version is maintained by the <code>.pre-commit-config.yml</code> file.</p> <p>If you do not want to use pre-commit follow this guideline:</p> <ul> <li>Always install and use the latest version of ansible-lint. You can find the latest release version here. Install with:</li> </ul> <pre><code>pip3 install ansible-lint --user\n</code></pre> <ul> <li>Put the following two files in the home directory of each role, such as:</li> <li>.ansible-lint</li> <li>.yamllint.yml</li> </ul> <p>The files are configured to enforce most default ansible-lint rules but skip others based on certain development requirements and experiences.</p> <ul> <li>Put the following file into directory .github/workflow of each role, such as:</li> <li>.github/workflows/ansible-lint.yml</li> </ul> <p>This will trigger an ansible-lint run in a freshly created virtual system on GitHub after each git push or pull request.</p> <ul> <li>For skipping certain ansible-lint checks for certain tasks only, follow the chapter \"False Positives: Skipping Rules\" in https://ansible-lint.readthedocs.io/en/latest/rules.html:</li> </ul> <p>Add <code># noqa</code> after the task name, followed by a space and the rule name from Default Rules, e.g. <code>package-latest</code>. Also add a line starting with <code># Reason for noqa:</code>, followed by a space and a short explanation on why ansible-lint should not report a failure for the rule in this case.</p>"},{"location":"initiative_contribute/__create_a_fork/","title":"Setting up your local environment","text":"<p>As a new contributor, the first thing to do is to get yourself set up to contribute to a git repo.</p>"},{"location":"initiative_contribute/__create_a_fork/#forking-cloning","title":"Forking &amp; Cloning","text":"<ol> <li> <p>Create a Fork of the \"Official\" Repo</p> <p>A \"fork\" is essentially a server-side clone of a Git repository. In the pure git world this can be done with a <code>git clone</code> command on the Git server, but GitHub provides us a fork button to do this, just click it (in the upper right) and confirm you want to fork the repository into your own namespace.</p> </li> <li> <p>Clone your fork</p> <p>This one is pretty self explanatory. Just make sure you clone your fork and not the official fork.</p> <p><code>git clone git@github.com/yourname/repo.git</code></p> </li> <li> <p>Set your local clone up to track the \"Upstream\" fork</p> <p>When I clone a repository locally, that thing is appropriately referred to as your local repository. By default, when I run a <code>git clone</code>, git automatically sets up that local repo to track the remote repository I cloned from. However, since we cloned from our fork of the \"official\" repo, our local repo is now tracking our fork. In order to keep up with changes being made to the official repo, we want to set up our local repo to track the official fork, in addition to our own. This is called adding a remote. Here's how.</p> <p><code>git remote add upstream git@github.com/sap-linuxlab/repo.git</code> So the command we ran is <code>git remote add</code>, then we gave it the name \"upstream\" and passed the Git URL to that remote. For the record, \"upstream\" is the common name used to refer to the official fork of a git project, but I could have named it \"official\" or \"nutter-butter\" for all git cares.</p> </li> </ol>"},{"location":"initiative_contribute/__create_a_fork/#keeping-your-fork-up-to-date","title":"Keeping Your Fork Up-to-date","text":"<p>As time goes on and people contribute to the project, it's possible that the upstream repo will drift apart from your fork. It is your responsibility to make sure you are keeping your fork up to date with the latest changes from upstream. Usually this means making sure that the default branch of your repo is in the same state as the default branch of your fork. You can do this by occasionally pulling updates from upstream to your fork.</p> <p>NOTE: Usually the default branch of a repo is the \"master\" branch, but it's possible for some repos it could be something else. In GitHub, it's easy to know just by looking at whatever branch is the active one when you navigate to the main repo page, or do a <code>git clone</code>.</p> <p>There are two methods for updating your fork. Both are explained below.</p>"},{"location":"initiative_contribute/__create_a_fork/#option-1-rebase-recommended","title":"Option 1: Rebase (Recommended)","text":"<p>With a rebase you are essentially telling git to, first, copy the entire state of a remote branch to your local repo, then take any detected changes in my local copy and overlay them on top of the clean remote clone.</p> <pre><code>git checkout master # Make sure your local repo is on the master branch\ngit fetch upstream # Scan the remote for any updates\ngit rebase upstream/master # Rebase my local master on top of the master branch of upstream\n</code></pre> <p>Your local master branch is now up-to-date. However, this did not update your remote fork. To do that you have to push</p> <pre><code>git push\n</code></pre>"},{"location":"initiative_contribute/__create_a_fork/#option-2-merge","title":"Option 2: Merge","text":"<p>A merge is almost the exact opposite of a rebase. Instead of using the remote repo as the base, I'm going to use my local copy as the base, and attempt to overlay any changes since my last merge on top of my current branch. One of the advantages of a merge is that you get to see some output of the commits and files that have changed if that is of interest. The downside is that merging has the potential to cause more conflicts if you've made changes to your local copy AND changes have been made upstream.</p> <pre><code>git checkout master\ngit fetch upstream\ngit merge upstream/master\n</code></pre> <p>Your local master branch is now up-to-date. However, this did not update your remote fork. To do that you have to push</p> <pre><code>git push\n</code></pre>"},{"location":"initiative_contribute/__install_pre_commit/","title":"Installing pre-commit","text":"<p>pre-commit is a python program which can be installed with pip</p>"},{"location":"initiative_contribute/__install_pre_commit/#minimum-requirements","title":"Minimum requirements","text":"<ul> <li>pyhton 3.7 and higher</li> </ul>"},{"location":"initiative_contribute/__install_pre_commit/#installation-on-rhel8-defaults-to-pyhton-36","title":"Installation on RHEL8 (defaults to pyhton 3.6)","text":"<ol> <li> <p>Install Python 3.9  <pre> <code>\n    sudo dnf install python39-3.9.7\n</code></pre></p> </li> <li> <p>Create a venv and activate it <pre> <code>\n    /usr/bin/python3.9 -m venv ~/.venv/pre-commit \n    . ~/.venv/pre-commit/bin/activate\n    </code></pre></p> </li> <li> <p>Install pre-commit <pre> <code>\n    pip install --upgrade pip\n    pip install pre-commit\n    </code></pre></p> </li> <li> <p>Set an alias or link to <code>~/.venv/pre-commit/bin/pre-commit</code> to use it</p> </li> </ol> <p>On other Linux distributions with python 3.7 and later, you can either create a virtual environment or install with <code>pip install --user pre-commit</code></p>"},{"location":"initiative_contribute/__install_pre_commit/#using-pre-commit","title":"Using pre-commit","text":""},{"location":"initiative_contribute/__install_pre_commit/#configuration-files","title":"Configuration files","text":"<p>The config file for pre-commit are created in the root directory of github and is called <code>.pre-config.yml</code>.  In case of ansible collections other config files may apply such as <code>.ansible-lint</code> and <code>.yamllint</code>.  The required config files should be created and maintained by the repo maintainers. Hence they are automatcially downloaded with <code>git clone</code> and <code>git pull</code> commands</p>"},{"location":"initiative_contribute/__install_pre_commit/#activate-pre-commit","title":"Activate pre-commit","text":"<p>A repository maintainer activates pre-commit by running <code>pre-commit install</code> within a directory of the cloned repository</p>"},{"location":"initiative_contribute/__install_pre_commit/#deactivate-pre-commit","title":"Deactivate pre-commit","text":"<p>run <code>pre-commit uninstall</code> </p>"},{"location":"initiative_contribute/__install_pre_commit/#useful-commands","title":"Useful commands","text":"<p>When you first install pre-commit on a repository and you have created your confg file, you should run:</p> <pre><code>pre-commit run --all-files [--show-diff-on-failure]\n</code></pre> <p>The optional parameter <code>--show-diff-on-failure</code> prints the problematic code at the end of the run.</p>"},{"location":"initiative_contribute/form_request_apply_as_maintainer/","title":"Form request apply as maintainer","text":""},{"location":"initiative_contribute/form_request_apply_as_maintainer/#request-being-a-maintainers","title":"Request being a maintainers","text":"<p>Please fill the following form to become a maintainer</p>  Your email:   your Github Account:   Enter repsitory name you are applying for   Why are you applying as a maintainer for this repo  Send"},{"location":"initiative_contribute/form_request_submit_new_content/","title":"Form request submit new content","text":""},{"location":"initiative_contribute/form_request_submit_new_content/#request-for-creating-a-new-repository","title":"Request for creating a new repository","text":"<p>Please fill the following form to become a maintainer</p> Your email:       your Github Account:     Enter repository name you want to be created  Enter the path to the existing repository you want to add (or leave empty for new one)  Describe the content of this repository (Solution type, programming language, etc.)  Send"},{"location":"initiative_contribute/form_response_thank_you/","title":"Form response thank you","text":""},{"location":"initiative_contribute/form_response_thank_you/#thank-you","title":"Thank you","text":"<p>Your request has been submitted</p> <p>Back to Main</p>"}]}